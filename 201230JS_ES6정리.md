#### 02_Javascript ES6 정리

##### 01 let과 const

* let
  * let을 블록 스코프로 움직임 / {} 단위
  * var와 다르게 글로벌 스코프에 들어갈 수 없음(글로벌 위치에서 선언시 스크립트 스코프로 들어감)
  * 프로그램 시작전 엔진 초기화 단계에서 읽히지 않음(호이스팅이 안됨)
  * 쉼표를 통해 let을 생략하여 선언 가능(let a = 'a', b='b')
* const
  * 상수의 특징
  * 객체의 요소값 변환과 객체의 요소값 변환은 가능



##### 02 Arrow Function

* Arrow Function
  * function(){} 의 축약 형태이지만 this 참조가 다름

  * 객체 반환방법: 객체를 소괄호로 감싼 형태

    ```javascript
    const point = (param) => ({book:param}); 
    ```

  * 일반 함수와 차이

    * 일반함수 : prototype과 constructor가 있음
    * 화살표함수 : prototype이 없음 (가볍지만 메소드 연결 확장 불가) / new 연산자 사용 불가
      * arguments 사용 불가 / 대신 rest 파라미터 사용
    * 화살표 함수는 함수 기능만 가볍게 쓰자는 의미

* 화살표 함수와 this

  * strict 모드에서는 함수 호출시 호출하는 함수 앞에 오브젝트를 작성해야함

  * 화살표 함수에서 this가 글로벌 오브젝트를 참조함

    ```javascript
    "use strict"
    var point = 100;
    function sports(){
        const getPoint = () => {
            console.log(this.point)
        };
        getPoint();
    }
    window.sports(); // 100이 출력됨
    // 화살표 함수는 함수에 this를 가지고 있지 않기때문에 대부분의 경우 window 오브젝트를 참조함
    ```

  * 화살표함수가 this를 참조하는 논리

    * 화살표 함수는 정적(Lexical) 스코프의 this를 참조함

      * 엔진이 해석할 때, 화살표 함수를 만나면 function 오브젝트를 생성하고
      * 화살표함수가 **속한 스코프를 생성한 오브젝트에 바인딩**

    * 오브젝트에 바인딩된 스코프의 this를 화살표 함수에서도 사용함

      ```javascript
      var title = "책";
      const book = {
          show: () => console.log(this.title)
      };
      book.show();
      ```

      1. show의 스코프인 book 오브젝트에 설정된 this는 window
      2. 따라서 show의 this도 window를 참조한다.

* 화살표 함수와 인스턴스

  * 인스턴스에서 화살표 함수의 작성 위치에 따라 this가 참조하는 오브젝트가 달라짐

    ```javascript
    var point = 200;
    const Point = function(){
        this.point = 100;
    };
    Point.prototype.getPoint = () => {
        console.log(this.point);
    };
    new Point().getPoint();
    // prototype에 화살표 함수를 연결하면 Point의 this인 글로벌을 참조함
    // 200
    ```

    ```javascript
    const Point = function(){
        this.point = 100;
    };
    Point.prototype.getPoint = function(){
        const add = () => this.point + 20;
        console.log(add());
        [1, 2].forEach((value)=>{
            console.log(this.point + value);
        })
    };
    new Point().getPoint();
    // 화살표 함수의 스코프인 getPoint()의 this를 사용함
    // 120 101 102
    ```

  * 정리

    * 화살표함수는 prototype이 없으므로 함수가 가볍다
    * 화살표함수는 this가 없다
      * 화살표 함수는 Function 오브젝트를 생성할 때 정적으로 화살표 함수가 속한 스코프의 this를 화살표 함수에 바인딩한다.
      * 바인딩 된 this 참조가 바뀌지는 않음(일반 함수는 call() 등으로 바꿀 수 있음)



##### 03 이터레이션 프로토콜

* 이터레이션 프로토콜
  * 오브젝트가 이터레이션 할 수 있는(반복할 수 있는) 구조여야하며, 이터레이션 함수를 갖고 있어야한다.
    * Array, Argument, String, TypedArray, Map, Set, DOM NodeList
  * 구분
    * 이터러블 프로토콜
    * 이터레이터 프로토콜
  * 이터러블 오브젝트
    * 이터러블 프로토콜을 갖고 있는 오브젝트
    * 반복 구조, Symbol.iterator()
    * 자체 오브젝트에는 없지만 이터러블 오브젝트를 상속받아도 됨(즉, prototype chain에 있으면 됨)
* 이터레이터 프로토콜
  * 값을 순서대로 생성하는 방법(규약)
  * Symbol.iterator()를 호출하면 이터레이터 오브젝트를 생성하여 반환 / next() 호출해서 반환



##### 04 spread, rest

* Spread

  * 이터러블 오브젝트를 하나씩 전개해줌

  * Object는 이터러블 오브젝트가 아니지만 전개 가능 

    ```javascript
    const one = [21, 22];
    const two = [31, 32];
    const result = [11, ...one, 12, ...two];
    // [11, 21, 22, 12, 31, 32]
    
    const lib = {book: 10, music: 20};
    const result2 = {book: 30, ...one};
    // {book:10, music:20} 객체는 프로퍼티 이름이 같으면 값 대체
    ```

  * function spread

    ```javascript
    function add(one, two, three){
        console.log(one + two + three);
    }
    const values = [10, 20, 30];
    add(...values);
    ```

* rest 파라미터

  * 분리하여 받은 파라미터를 배열로 결합

  * 작성방법

    * 호출받는 함수의 파라미터에 ...에 이어서 파라미터 이름을 작성
    * 호출한 함수에서 보낸 순서로 매핑

    ```javascript
    function point(...param){ //이 부분이 rest, 파라미터를 다시 모아서 배열로 만들어줌
        console.log(param); // [10, 20, 30]
        console.log(Array.isArray(param));
    }
    const values = [10, 20, 30];
    point(...values);
    ```

* Array-like

  * Object 타입이지만 배열처럼 이터러블이 가능한 오브젝트
  * for() 문으로 전개 가능
  * 작성방법
    * 프로퍼티 key 값을 0부터 1씩 증가하면서 프로퍼티 값을 작성
    * length에 전체 프로퍼티 수 작성



##### 05 Destructuring

* 분할할당(Destructuring Assignment)

  * 코드예제

    ```javascript
    let one, two, three;
    const list = [1, 2, 3];
    [one, two, three] = list;
    console.log(one); // 1
    console.log(two); // 2
    console.log(three); // 3
    ```

    * 할당받을 변수가 적으면 인덱스까지 할당 / 할당 받을 변수가 많으며, 초과 변수는 undefined 할당

  * spread 활용 예제

    ```javascript
    let one, rest;
    [one, ...rest] = [1, 2, 3, 4];
    console.log(one); // 1
    console.log(rest); // [2, 3, 4]
    ```

* Object 분할 할당

  * 프로퍼티 이름이 같은 프로퍼티 값을 할당

    ```javascript
    const {one, two} = {one: 10, two: 20};
    console.log(one); // 10
    console.log(two); // 20
    ```

  * 프로퍼티 이름을 별도로 작성

    ```javascript
    let one, two;
    ({one, two} = {one: 10, two: 20});
    console.log(one); // 10
    console.log(two); // 20
    ```

  * 값 위치에 변수 이름을 작성

    ```javascript
    let five, six;
    ({one: five, two: six} = {one: 5, two: 6});
    console.log(five); // 5
    console.log(six); //6
    ```

  * 나머지를 Object로 할당

    ```javascript
    const {one, ...rest} = {one: 10, two: 20, three: 30};
    console.log(rest); // {two: 20, three: 30}
    ```

  * 파라미터 값 할당

    ```javascript
    function add({one, two}){ //이름을 맞추어 파라미터를 넘겨줌
        console.log(one + two); // 30
    }
    add({one: 10, two: 20});
    ```

* Object 오퍼레이션

  * 객체에 같은 프로퍼티를 사용할 경우: ES5 - 에러 / ES6 - 뒤에 작성한 프로퍼티 값으로 대체됨

    * {book: 10, book: 20}; // {book: 20}

  * 변수 이름을 객체안의 키값으로 작성할 경우 []로 감싸면 된다.

    ```javascript
    const item = "book";
    const result = {[item]: title} = {book: "책"};
    console.log(result); //{book: 책}
    ```



##### 06 부가기능

* default value

  * 값을 할당하지 않으면 사전에 정의된 값을 할당

    ```javascript
    const [one, two, five = 50] = [10, 20];
    console.log(five); // 50
    // 할당할 값이 있으면 디폴드값은 무시됨
    ```

  * 디폴드 값은 왼쪽에서 오른쪽 순서로 적용됨

    ```javascript
    const [one, two = one + 20, five = two + 50] = [10];
    console.log(two); // 30
    console.log(five); // 80
    ```

    

  * 함수 파라미터에도 디폴드 값 적용 가능

    ```javascript
    const add = (ten, two = 20) => ten + two;
    const result = add(10);
    console.log(result); // 30
    ```

  * undefined 면 값을 넘겨주지 않은 것과 같다

    ```javascript
    const point = () => 20;
    const add = (one, two= pointI()) => one + two;
    const result = add(10, undefined);
    console.log(result); // 30
    ```

* 반복문

  * for-of

    * 이터러블 오브젝트를 반복
    * 이터러블 오브젝트를 반복할 때마다 variable에 값이 할당됨
    * 배열 / String / NodeList와 같은 이터러블 오브젝트를 사용할 수있음
    * Object / prototype의 프로퍼티는 전개되지 않음

  * for-in

    * 열거가능한 프로퍼티가 대상(enumerable이 true인 형태)

    * Object 형식은 열거가능

      ```javascript
      const obj = {};
      Object.defineProperties(obj, {
          sports: {
              enumerable: false, value: "스포츠"
          },
          book: {
              enumerable: true, value: "책"
          }
      });
      for(let item in obj){
          console.log(item + ": " + obj[item]);
      }; // book: 책
      ```

  * Object를 for-of로 전개하는 방법

    * Object.keys()로 프로퍼티 이름을 배열로 만들고 만든 배열을 for-of로 전개

      ```javascript
      const sports = {
          soccer: "축구",
          baseball: "야구"
      };
      const keyList = Object.keys(sports);
      
      for (let key of keyList){
          console.log(key + ": " + sports[key]);
      }
      // soccer: 축구 
      // baseball: 야구
      ```

* 개선된 표현식

  * 거듭제곱은 우결합성(오른쪽에서 왼쪽으로 계산)

    ```javascript
    console.log(2 ** 3 ** 2); // 512
    console.log(2 ** (3 ** 2)); // 512
    ```

  * try-catch에서 error 생략가능 (ES2019)

    ```javascript
    try{
        ....
    }catch{
        ....
    }
    ```

  * Object 내부에 함수를 작성할 때 function 키워드를 작성하지 않음(ES6)

    ```javascript
    const sports = {
        point: 100,
        getPoint(){
            return this.point;
        },
        //ES5 형태
        getvalue: function(){
            return this.point;
        }
    };
    console.log(sports.getPoint()); //100
    ```

* getter, setter

  * getter로 선언된 함수를 자동으로 호출

    * 값을 반환하는 시맨틱을 갖고 있으므로 getter 함수에서 값을 반환해야 합니다.

  * ES5

    ```javascript
    var book = {};
    Object.defineProperty(book, "title", {
        get: function(){
            return "책";
        }
    });
    console.log(book.title);
    ```

    * title 프로퍼티에서 get 속성을 체크하여 호출

  * ES6

    ```javascript
    const book = {
        point: 100,
        get getPoint(){
            return this.point;
        }
    };
    console.log(book.getPoint); // 100
    ```

    * getPoint() 앞에 get을 작성하면 getter로 선언됨
    * getPoint() 함수가 자동으로 호출됨
    * 다수의 getter 사용가능

  * setter는 프로퍼티에 값을 할당하면 setter로 선언된 함수가 자동으로 호출됨

    * 값을 설정하는 시맨틱을 갖고 있으므로 setter함수에서 값을 설정해야함

  * ES5

    ```javascript
    var book = {title: "HTML"};
    Object.defineProperty(book, "change", {
        set: function(param){
            this.title = param;
        }
    });
    book.change = "자바스크립트";
    console.log(book) // {title: 자바스크립트}
    ```

  * ES6

    ```javascript
    const book = {
        point: 100,
        set setPoint(param){
            this.point = param;
        }
    };
    book.setPoint = 200;
    console.log(book.point); // 200
    ```

  * setter 삭제

    ```javascript
    const name = "setPoint";
    const book = {
        set [name](param){
            this.point = param;
        }
    };
    delete book[name];
    debugger;
    console.log(book[name]); // undefined
    ```

    


#### SQL 기본 문법

1. 로직 순서

   * SQL 해석 순서는 FROM -> WHERE -> GROUP BY -> SELECT -> ORDER BY 순

2. DATETIME

   * 현재시간 : CURRENT_TIMESTAMP
   * 연/월/일/시만 추출 : ex) SELECT year('20200826')

3. CASE

   ```sql
   -- 패턴 1
   SELECT *,
   	CASE birthMonth
   		WHEN 1 THEN N'1월'
   		WHEN 2 THEN N'2월'
   		WHEN 3 THEN N'3월'
   		ELSE N'다른거'
   	END AS birthSeason
   FROM players;
   
   -- 패턴 2
   SELECT *,
   	CASE
   		WHEN birthMonth <= 2 THEN N'겨울'
   		WHEN birthMonth <= 5 THEN N'봄'
   		WHEN birthMonth <= 8 THEN N'여름'
   		ELSE N'다른거'
   	END AS birthSeason
   FROM players;
   ```

   

4. 집계함수

   * COUNT / SUM / AVG / MIN / MAX 등이 집계함수
   * 집계함수는 집합이 null이면 무시함(pass)

   > DISTINCT는 중복된 row를 제거함
   >  만약 SELECT DISTINCTbirthYear, birthMonth from players; 로 보면 
   >  birthYear과 birthMonth 모두 중복되는 경우만 판별함

   ```sql
   -- count
   SELECT COUNT(birthYear) FROM players;
   -- COUNT를 중복구분하는법(distinct 집합)
   SELECT COUNT(DISTINCT birthYear) FROM players;
   
   -- 선수들의 평균 weight 구해보자. 단, wieght = null인 경우라면 weight = 0으로 친다
   SELECT AVG(CASE WHEN weight IS NULL THEN 0 ELSE weight END) FROM players;
   ```

5. GROUP BY

   * 묶어서 분석하는경우 사용
   * 그룹내 중복된 값을 기본쿼리로는 추출하면 안됨(group 밖에 있으므로) 따라서 집계함수나 대표값을 정해줘야함
   * Grouping은 WHERE후에 이루어지기 때문에 GROUP BY된 부분을 조건으로 걸기 위해선 HAVING문을 사용해야함

   ```sql
   SELECT teamID, SUM(HR) AS homeRuns
   FROM batting
   WHERE yearID = 2004
   GROUP BY teamID
   HAVING SUM(HR) >= 200
   ORDER BY homeRuns DESC;
   ```

   * 칼럼을 세트로 Grouping을 하려면 쉼표(,) 추가해서 넣으면 됨

6. INSERT DELETE UPDATE

   * INSERT INTO [테이블명] VALUES ([값, ...])
   * DELETE FROM [테이블명] WHERE [조건]
   * UPDATE [테이블명] SET [열 = 값, ] WHERE [조건]
   * DELETE(물리 삭제) vs UPDATE(논리 삭제)

7. SUBQUERY

   * SQL 명령문 안에서 지정하는 하부 SELECT
   * 보통 WHERE에서 가장 많이 사용되지만, 나머지 구문(SELECT, INSERT 등)에서도 사용 가능
   * Subquery를 사용한 테이블 데이터 추출(복사)

   ```sql
   INSERT INTO salaries_temp SELECT yearID, playerID, salary FROM salaries;
   ```

   * 상관관계 서브쿼리

     * EXISTS, NOT EXISTS

     ```sql
     -- EXISTS 있으면 내부 셀렉트 추출하고 없으면 넘어가라
     SELECT * FROM players WHERE EXISTS (SELECT playerID FROM battingpost WHERE players.playerID = battingpost.playerID);
     ```

8. DB(Schema) 작성

   1. DB 생성

      * CREATE DATABASE GameDB;

   2. 테이블 생성

      * CREATE TABLE 테이블명(열이름 자료형 [DEFAULT 기본값] [NULL ..] ...)

      ```sql
      -- ex)
      CREATE TABLE accounts(accountID INTEGER NOT NULL PRIMARY KEY, accountName VARCHAR(10) NOT NULL, coins INTEGER DEFAULT 0, createdTime DATETIME);
      ```

   3. 테이블 삭제

      * DROP TABLE [테이블명];

   4. 테이블 변경(ALTER)

      * 열추가(ADD) / 열삭제(DROP) / 변경(ALTER)가 있음

      * ALTER TABLE [테이블명] ADD [열이름 자료형 null..];
      * ALTER TABLE [테이블명] DROP COLUMN [열이름];
      * ALTER TABLE [테이블명] ALTER COLUMN [열이름 자료형 nul..];

   5. 제약(CONSTRAINT) 추가 / 삭제 (ex. NOT NULL, PRIMARY KEY)

      * ALTER TABLE [테이블명] ADD CONSTRAINT [임의 이름] PRIMARY KEY ([열이름]);
      * ALTER TABLE [테이블명] DROP CONSTRAINT [임의 이름];

9. 정규화

   * 테이블을 올바르게 변경하고 분할하는 것

10. 인덱스

    * 인덱스는 이진검색트리 사용 (따라서 빠르게 검색가능)
    * 기준으로 자주 검색할 칼럼을 대상으로 인덱스를 걸어줌
    * 종류 : CLUSTERED / NON-CLUSTERED
      * CLUSTERED는 테이블당 1개만 존재 / 보통 PRIMARY KEY (데이터가 정렬된 상태로 저장)
        * CLUSTERED INDEX는 유일성이 보장되어야함
      * 나머지는 NON-CLUSTERED
        * NON-CLUSTERED는 색인의 개념 (보통 책의 후반에 나오는 LOOKUP 테이블)
    * 인덱스 생성 / 삭제
      * CREATE [추가할 CONSTRAINT] INDEX [지을 이름] ON \[테이블명](칼럼명);
      * DROP INDEX [테이블명].[인덱스명];

11. UNION

    * UNION (중복 제거)

    * 쿼리 UNION 쿼리 (기본 UNION은 DINTINCT가 포함되어있다고 생각하면 됨 / 중복값은 제거됨)
    * 중복을 허용해야하면 UNION ALL 사용
    * cf) 교집합 : INTERSECT / 차집합 : EXCEPT

12. JOIN

    * 테이블 간 결합

    1. CROSS JOIN (교차 결합)

       * 서로 교차를 하면서 결합

       ```sql
       SELECT * FROM testA CROSS JOIN testB;
       SELECT * FROM testA, testB;
       ```

       * 데이터가 조금만 많아져도 부담되는 연산이 생김

    2. INNER JOIN

       * 두개의 테이블을 가로로 결합

       ```sql
       SELECT * FROM players INNER JOIN salaries ON players.playerID = salaries.playerID
       ```

       * 데이터가 한쪽에 없으면 추출이 안됨(조건에 둘다 있는 경우만 추출)

    3. OUTER JOIN

       * 외부 결합
       * LEFT / RIGHT : 한쪽에만 데이터가 존재할 때 정책

       ```sql
       -- 왼쪽 데이터 값 표시 / 오른쪽 데이터에 정보가 없으면 NULL로 채워서 출력
       SELECT * FROM players LEFT JOIN salaries ON players.playerID = salaries.playerID
       -- 오른쪽 데이터 값 표시 / 왼쪽 데이터에 정보가 없으면 NULL로 채워서 출력
       SELECT * FROM players RIGHT JOIN salaries ON players.playerID = salaries.playerID
       ```

       

13. TRANSACTION

    * BEGIN TRAN / COMMIT / ROLLBACK 으로 구성
    * 트랜잭션은 원자성을 만족해야함(트랜잭션에 들어가는 모든 쿼리가 모두 성공하던가 아님 실패해야함)
    * BEGIN TRAN으로 임시 처리 / COMMIT을 통해 임시 처리된 로직을 반영 / ROLLBACK으로 취소

    ```sql
    BEGIN TRY
    	BEGIN TRAN;
    		INSERT INTO accounts VALUES(1, 'aa', 100);
    		INSERT INTO accounts VALUES(2, 'bb', 200);
    	COMMIT;
    END TRY
    BEGIN CATCH
    	IF @@TRANCOUNT > 0 -- 현재 활성화된 트랜잭션 수를 반환
    		ROLLBACK
    END CATCH
    ```

    * TRAN 사용시 주의점 : TRAN 안에는 꼭 원자적으로 실행될 애들만 넣어야함(성능 Risk)
      * TRAN이 물고있으면 Lock이 걸려서 다른 쿼리 실행을 못함

14. 변수와 흐름 제어

    * 변수 선언 : DECLARE @i AS INT = 10;
    * 변수 세팅 : SET @i = 10;
    * 변수 예제

    ```sql
    DECLARE @firstName AS NVARCHAR(15);
    DECLARE @lastName AS NVARCHAR(15);
    
    SET @firstName = (SELECT TOP 1 nameFirst FROM players);
    
    -- 변수 조회
    SELECT @firstName;
    
    --------------------- 배치(batch) ---------------------------
    -- 배치는 하나의 묶음으로 분석되고 실행되는 명령어 집합
    -- 이전 변수 제외하고 새로 시작
    GO
    
    -- 배치를 이용해 변수의 유효범위 설정 가능
    DECLARE @i AS INT = 10;
    
    ------------------------ 흐름 제어 ----------------------------
    
    -- IF
    GO
    DECLARE @i AS INT = 10;
    
    -- BEGIN END는 IF절을 묶어주는 {}과 같은 역할
    IF @i = 10
    BEGIN
    	PRINT('BINGO!');
    END
    ELSE
    	PRINT('NO');
    
    -- WHILE / BREAK CONTINUE 가능
    GO
    DECLARE @i AS INT = 0;
    WHILE @i <= 10
    BEGIN
    	PRINT @i;
    	SET @i = @i +1;
    	IF @i = 6 BREAK;
    END
    
    --------------------------- 테이블 변수 ----------------------------
    
    -- 임시로 사용할 테이블을 변수로 만들 수 있다!
    -- testA, testB 만들고 삭제 -> NO!
    -- DECLARE를 사용 -> tempdb 데이터베이스에 임시 저장
    
    DECLARE @test TABLE
    (
    	name VARCHAR(50) NOT NULL,
        salary INT NOT NULL
        
    );
    
    INSERT INTO @test
    SELECT *
    FROM players AS p
    	INNER JOIN salaries AS a
    	ON p.playerID = s.playerID;
    	
    SELECT * FROM @test;	
    ```

15. 윈도우 함수

    * 행들의 서브 집합을 대상으로, 각 행별로 계산을 해서 스칼라(단일 고정)값을 출력하는 함수

    ```sql
    -- ~OVER([PARTITION] [ORDER BY] [ROWS])
    
    -- PARTITION은 서브셋 Grouping 용도
    -- 전체 데이터를 연봉 순서로 나열하고, 순위 표기
    
    SELECT *, ROW_NUMBER() OVER (ORDER BY salary DESC), -- 행 번호
    	RANK() OVER (ORDER BY salary DESC), -- 랭킹 표시(공동 1등 이후 3등)
    	DENSE_RANK() OVER (ORDER BY salary DESC), -- 랭킹(공동 1등 이후 2등)
    	NTILE(100) OVER (ORDER BY salary DESC) -- 상위 몇%
    FROM salaries;
    
    
    -- playerID 별 순위를 따로 하고 싶다면
    SELECT *,
    	ROW_NUMBER() OVER (PARTITION BY playerID ORDER BY salary DESC),
    	RANK() OVER (PARTITION BY playerID ORDER BY salary DESC)
    FROM salaries
    ORDER BY playerID;
    
    -- LAG(바로 이전), LEAD(바로 다음)
    SELECT *,
    	LAG(salary) OVER (PARTITION BY playerID ORDER BY salary DESC) AS prevSalary,
    	LEAD(salary) OVER (PARTITION BY playerID ORDER BY salary DESC) AS nextSalary
    FROM salaries
    ORDER BY playerID;
    
    -- FIRST_VALUE, LAST_VALUE
    SELECT *,
    	FIRST_VALUE(salary) OVER (PARTITION BY playerID ORDER BY salary DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS best,
    	LAST_VALUE(salary) OVER (PARTITION BY playerID ORDER BY salary DESC ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS worst
    FROM salaries
    ORDER BY playerID;
    
    ```

16. sdafsadf

17. ㄴㅇㅁㄻㄴㅇㄹ

18. ㄴㅇㄹㄴㅇㄹ